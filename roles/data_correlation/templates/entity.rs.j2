use std::collections::HashMap;
use serde::{Serialize, Deserialize};

/// Entity type representation
pub type EntityType = String;

/// Entity representation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Entity {
    /// Unique identifier for the entity
    pub id: String,
    
    /// Type of entity (e.g., email, domain, username, etc.)
    #[serde(rename = "type")]
    pub entity_type: EntityType,
    
    /// Main value of the entity
    pub value: String,
    
    /// Additional attributes
    pub attributes: HashMap<String, String>,
    
    /// Sources that contributed to this entity
    pub sources: Vec<String>,
    
    /// Confidence score (0.0-1.0)
    pub confidence: f32,
    
    /// Last updated timestamp (ISO-8601)
    pub last_updated: String,
}

impl Entity {
    /// Create a new entity
    pub fn new(entity_type: &str, value: &str, source: &str) -> Self {
        let id = format!("{}:{}", entity_type, value);
        Self {
            id,
            entity_type: entity_type.to_string(),
            value: value.to_string(),
            attributes: HashMap::new(),
            sources: vec![source.to_string()],
            confidence: 0.7,  // Default confidence
            last_updated: chrono::Utc::now().to_rfc3339(),
        }
    }
    
    /// Add a source to the entity
    pub fn add_source(&mut self, source: &str) {
        if !self.sources.contains(&source.to_string()) {
            self.sources.push(source.to_string());
            // Increase confidence slightly for multiple sources
            self.confidence = (self.confidence + 0.1).min(1.0);
            self.last_updated = chrono::Utc::now().to_rfc3339();
        }
    }
    
    /// Add an attribute to the entity
    pub fn add_attribute(&mut self, key: &str, value: &str) {
        self.attributes.insert(key.to_string(), value.to_string());
        self.last_updated = chrono::Utc::now().to_rfc3339();
    }
    
    /// Set confidence score
    pub fn set_confidence(&mut self, confidence: f32) {
        self.confidence = confidence.min(1.0).max(0.0);
        self.last_updated = chrono::Utc::now().to_rfc3339();
    }
    
    /// Merge with another entity
    pub fn merge(&mut self, other: &Entity) {
        // Only merge entities of the same type and value
        if self.entity_type != other.entity_type || self.value != other.value {
            return;
        }
        
        // Merge sources
        for source in &other.sources {
            self.add_source(source);
        }
        
        // Merge attributes (keep existing attributes if key conflicts)
        for (key, value) in &other.attributes {
            if !self.attributes.contains_key(key) {
                self.add_attribute(key, value);
            }
        }
        
        // Take the highest confidence
        if other.confidence > self.confidence {
            self.confidence = other.confidence;
        }
        
        self.last_updated = chrono::Utc::now().to_rfc3339();
    }
}