use clap::{Parser, Subcommand};
use log::{info, warn, error};
use std::path::{Path, PathBuf};
use std::time::Instant;
use anyhow::{Context, Result};
use chrono::Local;

use osint_correlator::parsers::{parse_tool_data, ToolData};
use osint_correlator::entity::Entity;
use osint_correlator::relationship::Relationship;
use osint_correlator::correlator::Correlator;
use osint_correlator::visualizer::generate_visualizations;
use osint_correlator::report::generate_report;

/// OSINT Correlator - A lightweight tool for correlating OSINT data
#[derive(Parser)]
#[command(name = "osint-correlator")]
#[command(author = "OSINT Commander")]
#[command(version = "0.1.0")]
#[command(about = "Correlates OSINT data from multiple sources", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run full analysis on a target
    Analyze {
        /// Target identifier (username, domain, email, etc.)
        target: String,
        
        /// Base directory for OSINT data
        #[arg(short, long, default_value = "{{ osint_data_dir }}")]
        data_dir: PathBuf,
        
        /// Output directory for analysis results
        #[arg(short, long)]
        output_dir: Option<PathBuf>,
        
        /// Confidence threshold (0.0-1.0) for including entities and relationships
        #[arg(short, long, default_value_t = 0.6)]
        threshold: f32,
        
        /// Skip visualization generation
        #[arg(long)]
        skip_viz: bool,
        
        /// Skip report generation
        #[arg(long)]
        skip_report: bool,
    },
    
    /// Generate visualizations from existing analysis
    Visualize {
        /// Directory containing analysis results
        dir: PathBuf,
        
        /// Output format (dot, svg, png)
        #[arg(short, long, default_value = "svg")]
        format: String,
    },
    
    /// Generate report from existing analysis
    Report {
        /// Directory containing analysis results
        dir: PathBuf,
        
        /// Report format (html, json, markdown)
        #[arg(short, long, default_value = "html")]
        format: String,
    },
}

fn main() -> Result<()> {
    // Initialize logging
    env_logger::init();
    
    // Parse command line args
    let cli = Cli::parse();
    
    // Execute appropriate command
    match cli.command {
        Commands::Analyze { 
            target, 
            data_dir, 
            output_dir, 
            threshold, 
            skip_viz, 
            skip_report 
        } => {
            analyze_target(target, data_dir, output_dir, threshold, skip_viz, skip_report)
        },
        
        Commands::Visualize { dir, format } => {
            visualize_analysis(dir, format)
        },
        
        Commands::Report { dir, format } => {
            generate_report_cmd(dir, format)
        },
    }
}

fn analyze_target(
    target: String,
    data_dir: PathBuf,
    output_dir: Option<PathBuf>,
    threshold: f32,
    skip_viz: bool,
    skip_report: bool,
) -> Result<()> {
    let start_time = Instant::now();
    info!("Starting analysis for target: {}", target);
    
    // Determine output directory
    let timestamp = Local::now().format("%Y%m%d_%H%M%S");
    let output_path = match output_dir {
        Some(path) => path,
        None => {
            let base_output_dir = Path::new("{{ osint_base_dir }}/analysis/output");
            base_output_dir.join(format!("{}_{}", target, timestamp))
        }
    };
    
    // Create output directory if it doesn't exist
    std::fs::create_dir_all(&output_path)
        .context("Failed to create output directory")?;
    
    info!("Output will be saved to: {}", output_path.display());
    
    // Determine target directory
    let target_dir = data_dir.join(&target);
    
    if !target_dir.exists() {
        warn!("Target directory does not exist: {}", target_dir.display());
        warn!("Will look for data in the base directory instead");
        // Fall back to base directory
    }
    
    // Step 1: Load data from OSINT tools
    info!("Loading data from OSINT tools...");
    let tool_data = parse_tool_data(&target, &target_dir, &data_dir)?;
    
    // Save raw tool data for reference
    let raw_data_path = output_path.join("raw_tool_data.json");
    std::fs::write(&raw_data_path, serde_json::to_string_pretty(&tool_data)?)
        .context("Failed to save raw tool data")?;
    
    info!("Loaded data from {} tools", tool_data.len());
    
    // Step 2: Extract and correlate entities
    info!("Extracting and correlating entities...");
    let mut correlator = Correlator::new(target.clone(), threshold);
    
    // Process the tool data
    correlator.process_tool_data(&tool_data);
    
    // Get entities and relationships
    let entities = correlator.get_entities();
    let relationships = correlator.get_relationships();
    
    info!("Extracted {} unique entities", entities.len());
    info!("Found {} relationships", relationships.len());
    
    // Save entities and relationships
    let entities_path = output_path.join("entities.json");
    std::fs::write(&entities_path, serde_json::to_string_pretty(&entities)?)
        .context("Failed to save entities")?;
    
    let relationships_path = output_path.join("relationships.json");
    std::fs::write(&relationships_path, serde_json::to_string_pretty(&relationships)?)
        .context("Failed to save relationships")?;
    
    // Step 3: Build and save graph
    info!("Building entity relationship graph...");
    let graph = correlator.build_graph();
    
    let graph_path = output_path.join("graph.json");
    std::fs::write(&graph_path, serde_json::to_string_pretty(&graph)?)
        .context("Failed to save graph")?;
    
    // Step 4: Generate visualizations
    if !skip_viz {
        info!("Generating visualizations...");
        let viz_dir = output_path.join("viz");
        std::fs::create_dir_all(&viz_dir)
            .context("Failed to create visualization directory")?;
        
        let viz_files = generate_visualizations(&graph, &viz_dir, &target)?;
        info!("Generated {} visualizations", viz_files.len());
    }
    
    // Step 5: Generate report
    if !skip_report {
        info!("Generating analysis report...");
        let report_path = generate_report(
            &target,
            &entities,
            &relationships,
            &graph,
            &tool_data,
            &output_path,
            Path::new("{{ osint_base_dir }}/analysis/schemas"),
        )?;
        info!("Report generated: {}", report_path.display());
    }
    
    // Create summary file
    let summary = serde_json::json!({
        "target": target,
        "timestamp": timestamp.to_string(),
        "entity_count": entities.len(),
        "relationship_count": relationships.len(),
        "tools_analyzed": tool_data.keys().collect::<Vec<_>>(),
        "output_directory": output_path.to_string_lossy(),
        "duration_seconds": start_time.elapsed().as_secs()
    });
    
    let summary_path = output_path.join("analysis_summary.json");
    std::fs::write(&summary_path, serde_json::to_string_pretty(&summary)?)
        .context("Failed to save analysis summary")?;
    
    info!("Analysis complete in {:?}", start_time.elapsed());
    info!("Results saved to: {}", output_path.display());
    
    Ok(())
}

fn visualize_analysis(dir: PathBuf, format: String) -> Result<()> {
    info!("Visualizing analysis from: {}", dir.display());
    
    // Load graph from file
    let graph_path = dir.join("graph.json");
    let graph_data = std::fs::read_to_string(&graph_path)
        .context("Failed to read graph file")?;
    
    let graph = serde_json::from_str(&graph_data)
        .context("Failed to parse graph data")?;
    
    // Extract target name from directory
    let target = dir.file_name()
        .and_then(|name| name.to_str())
        .and_then(|name| name.split('_').next())
        .unwrap_or("unknown");
    
    // Generate visualizations
    let viz_dir = dir.join("viz");
    std::fs::create_dir_all(&viz_dir)
        .context("Failed to create visualization directory")?;
    
    let viz_files = generate_visualizations(&graph, &viz_dir, target)?;
    
    info!("Generated {} visualizations", viz_files.len());
    info!("Visualizations saved to: {}", viz_dir.display());
    
    Ok(())
}

fn generate_report_cmd(dir: PathBuf, format: String) -> Result<()> {
    info!("Generating report from: {}", dir.display());
    
    // Load entities and relationships
    let entities_path = dir.join("entities.json");
    let entities_data = std::fs::read_to_string(&entities_path)
        .context("Failed to read entities file")?;
    
    let entities: Vec<Entity> = serde_json::from_str(&entities_data)
        .context("Failed to parse entities data")?;
    
    let relationships_path = dir.join("relationships.json");
    let relationships_data = std::fs::read_to_string(&relationships_path)
        .context("Failed to read relationships file")?;
    
    let relationships: Vec<Relationship> = serde_json::from_str(&relationships_data)
        .context("Failed to parse relationships data")?;
    
    // Load graph if available
    let graph_path = dir.join("graph.json");
    let graph = if graph_path.exists() {
        let graph_data = std::fs::read_to_string(&graph_path)
            .context("Failed to read graph file")?;
        
        serde_json::from_str(&graph_data)
            .context("Failed to parse graph data")?
    } else {
        // Create empty graph
        Default::default()
    };
    
    // Extract target name from directory
    let target = dir.file_name()
        .and_then(|name| name.to_str())
        .and_then(|name| name.split('_').next())
        .unwrap_or("unknown")
        .to_string();
    
    // Generate report
    let report_path = generate_report(
        &target,
        &entities,
        &relationships,
        &graph,
        &ToolData::new(), // Empty tool data as we don't need raw data
        &dir,
        Path::new("{{ osint_base_dir }}/analysis/schemas"),
    )?;
    
    info!("Report generated: {}", report_path.display());
    
    Ok(())
}