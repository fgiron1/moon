use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use std::fs::{self, File};
use std::io::{self, Read};
use log::{info, warn, error, debug};
use regex::Regex;
use csv::Reader;
use serde::{Serialize, Deserialize};
use anyhow::{Context, Result, anyhow};
use glob::glob;
use rayon::prelude::*;

use crate::entity::{Entity, EntityType};

/// Map of tool names to their parsed data
pub type ToolData = HashMap<String, Vec<serde_json::Value>>;

/// Parse data from all OSINT tools for a given target
pub fn parse_tool_data(
    target: &str, 
    target_dir: &Path, 
    data_dir: &Path
) -> Result<ToolData> {
    let mut tool_data = ToolData::new();
    
    // Check if target directory exists
    if target_dir.exists() && target_dir.is_dir() {
        // Iterate through subdirectories (tool directories)
        for entry in fs::read_dir(target_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                let tool_name = path.file_name()
                    .and_then(|name| name.to_str())
                    .unwrap_or("unknown")
                    .to_string();
                
                debug!("Parsing data from tool: {}", tool_name);
                
                // Parse tool data based on tool name
                match tool_name.as_str() {
                    "bbot" => {
                        tool_data.insert(tool_name.clone(), parse_bbot_data(&path)?);
                    },
                    "sherlock" => {
                        tool_data.insert(tool_name.clone(), parse_sherlock_data(&path)?);
                    },
                    "spiderfoot" => {
                        tool_data.insert(tool_name.clone(), parse_spiderfoot_data(&path)?);
                    },
                    "theHarvester" => {
                        tool_data.insert(tool_name.clone(), parse_harvester_data(&path)?);
                    },
                    "phoneinfoga" => {
                        tool_data.insert(tool_name.clone(), parse_phoneinfoga_data(&path)?);
                    },
                    "holehe" => {
                        tool_data.insert(tool_name.clone(), parse_holehe_data(&path)?);
                    },
                    // Add other tools as needed
                    _ => {
                        // Use generic parser for unknown tools
                        let data = parse_generic_data(&path)?;
                        if !data.is_empty() {
                            tool_data.insert(tool_name.clone(), data);
                        }
                    }
                }
            }
        }
    } else {
        // If target directory doesn't exist, try to find data in the base directory
        warn!("Target directory not found: {}", target_dir.display());
        info!("Looking for data in base directory: {}", data_dir.display());
        
        // Search for tools in base directory
        for entry in fs::read_dir(data_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                let dir_name = path.file_name()
                    .and_then(|name| name.to_str())
                    .unwrap_or("")
                    .to_string();
                
                // Skip directories that are clearly for other targets
                if dir_name != target && 
                   !dir_name.starts_with(target) && 
                   !dir_name.ends_with(target) &&
                   dir_name != "common" {
                    continue;
                }
                
                // Find tool directories within this directory
                for tool_entry in fs::read_dir(&path)? {
                    let tool_entry = tool_entry?;
                    let tool_path = tool_entry.path();
                    
                    if tool_path.is_dir() {
                        let tool_name = tool_path.file_name()
                            .and_then(|name| name.to_str())
                            .unwrap_or("unknown")
                            .to_string();
                        
                        debug!("Parsing data from tool: {} in directory: {}", tool_name, dir_name);
                        
                        // Parse tool data
                        let data = match tool_name.as_str() {
                            "bbot" => parse_bbot_data(&tool_path)?,
                            "sherlock" => parse_sherlock_data(&tool_path)?,
                            "spiderfoot" => parse_spiderfoot_data(&tool_path)?,
                            "theHarvester" => parse_harvester_data(&tool_path)?,
                            "phoneinfoga" => parse_phoneinfoga_data(&tool_path)?,
                            "holehe" => parse_holehe_data(&tool_path)?,
                            // Add other tools as needed
                            _ => parse_generic_data(&tool_path)?
                        };
                        
                        if !data.is_empty() {
                            tool_data.insert(tool_name, data);
                        }
                    }
                }
            }
        }
    }
    
    // Check if we found any data
    if tool_data.is_empty() {
        warn!("No OSINT data found for target: {}", target);
    } else {
        info!("Loaded data from {} tools", tool_data.len());
        
        // Log number of items found for each tool
        for (tool, data) in &tool_data {
            info!("  {}: {} items", tool, data.len());
        }
    }
    
    Ok(tool_data)
}

/// Parse bbot output data
fn parse_bbot_data(tool_dir: &Path) -> Result<Vec<serde_json::Value>> {
    let mut data = Vec::new();
    
    // Find JSON files
    for entry in glob(&format!("{}/*.json", tool_dir.display()))? {
        let path = entry?;
        let file_content = fs::read_to_string(&path)?;
        
        match serde_json::from_str(&file_content) {
            Ok(serde_json::Value::Array(items)) => {
                data.extend(items);
            },
            Ok(serde_json::Value::Object(obj)) => {
                // Handle different bbot output formats
                if let Some(serde_json::Value::Array(events)) = obj.get("events") {
                    data.extend(events.clone());
                } else if let Some(serde_json::Value::Array(results)) = obj.get("results") {
                    data.extend(results.clone());
                } else {
                    // Just add the whole object
                    data.push(serde_json::Value::Object(obj));
                }
            },
            Err(e) => {
                warn!("Error parsing JSON from {:?}: {}", path, e);
            },
            _ => {}
        }
    }
    
    // Find CSV files
    for entry in glob(&format!("{}/*.csv", tool_dir.display()))? {
        let path = entry?;
        let mut rdr = csv::Reader::from_path(&path)?;
        
        let headers = match rdr.headers() {
            Ok(headers) => headers.clone(),
            Err(_) => continue,
        };
        
        for result in rdr.records() {
            let record = match result {
                Ok(record) => record,
                Err(_) => continue,
            };
            
            let mut map = serde_json::Map::new();
            for (i, field) in record.iter().enumerate() {
                if i < headers.len() {
                    map.insert(
                        headers[i].to_string(),
                        serde_json::Value::String(field.to_string()),
                    );
                }
            }
            
            data.push(serde_json::Value::Object(map));
        }
    }
    
    // Find text files and extract data using regex
    for entry in glob(&format!("{}/*.txt", tool_dir.display()))? {
        let path = entry?;
        let content = fs::read_to_string(&path)?;
        
        // Extract domains
        let domain_regex = Regex::new(r"\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b")?;
        for cap in domain_regex.captures_iter(&content) {
            let domain = cap.get(0).unwrap().as_str();
            let mut map = serde_json::Map::new();
            map.insert("type".to_string(), serde_json::Value::String("domain".to_string()));
            map.insert("value".to_string(), serde_json::Value::String(domain.to_string()));
            map.insert("source".to_string(), serde_json::Value::String("bbot_txt".to_string()));
            data.push(serde_json::Value::Object(map));
        }
        
        // Extract IP addresses
        let ip_regex = Regex::new(r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")?;
        for cap in ip_regex.captures_iter(&content) {
            let ip = cap.get(0).unwrap().as_str();
            let mut map = serde_json::Map::new();
            map.insert("type".to_string(), serde_json::Value::String("ip_address".to_string()));
            map.insert("value".to_string(), serde_json::Value::String(ip.to_string()));
            map.insert("source".to_string(), serde_json::Value::String("bbot_txt".to_string()));
            data.push(serde_json::Value::Object(map));
        }
        
        // Extract emails
        let email_regex = Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b")?;
        for cap in email_regex.captures_iter(&content) {
            let email = cap.get(0).unwrap().as_str();
            let mut map = serde_json::Map::new();
            map.insert("type".to_string(), serde_json::Value::String("email".to_string()));
            map.insert("value".to_string(), serde_json::Value::String(email.to_string()));
            map.insert("source".to_string(), serde_json::Value::String("bbot_txt".to_string()));
            data.push(serde_json::Value::Object(map));
        }
    }
    
    Ok(data)
}

/// Parse other tool data...
/// Similar implementations for parse_sherlock_data, parse_spiderfoot_data, etc.

/// Parse generic data - catch-all parser for unknown tools
fn parse_generic_data(tool_dir: &Path) -> Result<Vec<serde_json::Value>> {
    let mut data = Vec::new();
    
    // Find JSON files recursively
    for entry in glob(&format!("{}/**/*.json", tool_dir.display()))? {
        let path = entry?;
        let file_content = fs::read_to_string(&path)?;
        
        match serde_json::from_str(&file_content) {
            Ok(serde_json::Value::Array(items)) => {
                data.extend(items);
            },
            Ok(serde_json::Value::Object(obj)) => {
                data.push(serde_json::Value::Object(obj));
            },
            Err(e) => {
                debug!("Error parsing JSON from {:?}: {}", path, e);
            },
            _ => {}
        }
    }
    
    // Find CSV files recursively
    for entry in glob(&format!("{}/**/*.csv", tool_dir.display()))? {
        let path = entry?;
        let mut rdr = csv::Reader::from_path(&path)?;
        
        let headers = match rdr.headers() {
            Ok(headers) => headers.clone(),
            Err(_) => continue,
        };
        
        for result in rdr.records() {
            let record = match result {
                Ok(record) => record,
                Err(_) => continue,
            };
            
            let mut map = serde_json::Map::new();
            for (i, field) in record.iter().enumerate() {
                if i < headers.len() {
                    map.insert(
                        headers[i].to_string(),
                        serde_json::Value::String(field.to_string()),
                    );
                }
            }
            
            data.push(serde_json::Value::Object(map));
        }
    }
    
    // Find text files and extract common patterns
    for entry in glob(&format!("{}/**/*.txt", tool_dir.display()))? {
        let path = entry?;
        let content = fs::read_to_string(&path)?;
        
        // Extract structured data using regex patterns
        extract_common_patterns(&content, "generic_txt", &mut data)?;
    }
    
    Ok(data)
}

/// Extract common data patterns from text content
fn extract_common_patterns(content: &str, source: &str, data: &mut Vec<serde_json::Value>) -> Result<()> {
    // Extract domains
    let domain_regex = Regex::new(r"\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b")?;
    for cap in domain_regex.captures_iter(content) {
        let domain = cap.get(0).unwrap().as_str();
        let mut map = serde_json::Map::new();
        map.insert("type".to_string(), serde_json::Value::String("domain".to_string()));
        map.insert("value".to_string(), serde_json::Value::String(domain.to_string()));
        map.insert("source".to_string(), serde_json::Value::String(source.to_string()));
        data.push(serde_json::Value::Object(map));
    }
    
    // Extract IP addresses
    let ip_regex = Regex::new(r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")?;
    for cap in ip_regex.captures_iter(content) {
        let ip = cap.get(0).unwrap().as_str();
        if is_valid_ip(ip) {
            let mut map = serde_json::Map::new();
            map.insert("type".to_string(), serde_json::Value::String("ip_address".to_string()));
            map.insert("value".to_string(), serde_json::Value::String(ip.to_string()));
            map.insert("source".to_string(), serde_json::Value::String(source.to_string()));
            data.push(serde_json::Value::Object(map));
        }
    }
    
    // Extract emails
    let email_regex = Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b")?;
    for cap in email_regex.captures_iter(content) {
        let email = cap.get(0).unwrap().as_str();
        let mut map = serde_json::Map::new();
        map.insert("type".to_string(), serde_json::Value::String("email".to_string()));
        map.insert("value".to_string(), serde_json::Value::String(email.to_string()));
        map.insert("source".to_string(), serde_json::Value::String(source.to_string()));
        data.push(serde_json::Value::Object(map));
    }
    
    // Extract phone numbers
    let phone_regex = Regex::new(r"\+?\d{1,4}?[-.\s]?\(?\d{1,3}?\)?[-.\s]?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}")?;
    for cap in phone_regex.captures_iter(content) {
        let phone = cap.get(0).unwrap().as_str();
        let mut map = serde_json::Map::new();
        map.insert("type".to_string(), serde_json::Value::String("phone".to_string()));
        map.insert("value".to_string(), serde_json::Value::String(phone.to_string()));
        map.insert("source".to_string(), serde_json::Value::String(source.to_string()));
        data.push(serde_json::Value::Object(map));
    }
    
    // Extract usernames (common format)
    let username_regex = Regex::new(r"(?i)username:?\s*([a-z0-9_\-.]{3,30})")?;
    for cap in username_regex.captures_iter(content) {
        if let Some(username_match) = cap.get(1) {
            let username = username_match.as_str();
            let mut map = serde_json::Map::new();
            map.insert("type".to_string(), serde_json::Value::String("username".to_string()));
            map.insert("value".to_string(), serde_json::Value::String(username.to_string()));
            map.insert("source".to_string(), serde_json::Value::String(source.to_string()));
            data.push(serde_json::Value::Object(map));
        }
    }
    
    Ok(())
}

/// Check if a string is a valid IP address
fn is_valid_ip(ip: &str) -> bool {
    let parts: Vec<&str> = ip.split('.').collect();
    
    if parts.len() != 4 {
        return false;
    }
    
    for part in parts {
        match part.parse::<u8>() {
            Ok(_) => continue,
            Err(_) => return false,
        }
    }
    
    true
}

/// Extract entities from a parsed data item
pub fn extract_entities_from_item(
    item: &serde_json::Value, 
    source: &str
) -> Vec<Entity> {
    let mut entities = Vec::new();
    
    // Process based on item type
    if let serde_json::Value::Object(obj) = item {
        // Try to determine entity type
        let entity_type = if let Some(serde_json::Value::String(type_str)) = obj.get("type") {
            type_str.clone()
        } else {
            // Try to infer type from content
            infer_entity_type(obj)
        };
        
        if let Some(entity_type) = entity_type {
            // Extract the main value
            let value = extract_entity_value(obj, &entity_type);
            
            if let Some(value) = value {
                // Create the entity
                let mut entity = Entity {
                    id: format!("{}:{}", entity_type, value),
                    entity_type: entity_type.clone(),
                    value: value.clone(),
                    attributes: HashMap::new(),
                    sources: vec![source.to_string()],
                    confidence: calculate_confidence(item, source),
                    last_updated: chrono::Utc::now().to_rfc3339(),
                };
                
                // Extract attributes
                for (key, value) in obj {
                    if !["id", "type", "value", "sources", "confidence"].contains(&key.as_str()) {
                        // Convert serde_json value to string if it's simple
                        if let Some(val_str) = value_to_string(value) {
                            entity.attributes.insert(key.clone(), val_str);
                        }
                    }
                }
                
                entities.push(entity);
            }
        }
    }
    
    entities
}

/// Infer entity type from object content
fn infer_entity_type(obj: &serde_json::Map<String, serde_json::Value>) -> Option<String> {
    // Check for common fields indicating type
    if obj.contains_key("email") {
        return Some("email".to_string());
    } else if obj.contains_key("domain") || obj.contains_key("hostname") {
        return Some("domain".to_string());
    } else if obj.contains_key("username") || obj.contains_key("user") {
        return Some("username".to_string());
    } else if obj.contains_key("phone") || obj.contains_key("number") {
        return Some("phone".to_string());
    } else if obj.contains_key("ip") || obj.contains_key("ipv4") || obj.contains_key("ipv6") {
        return Some("ip_address".to_string());
    }
    
    // Check the value field if present
    if let Some(serde_json::Value::String(value)) = obj.get("value") {
        // Email pattern check
        if value.contains('@') && value.split('@').nth(1).map_or(false, |part| part.contains('.')) {
            return Some("email".to_string());
        }
        // Domain pattern check
        else if value.contains('.') && !value.starts_with("http") {
            return Some("domain".to_string());
        }
        // IP address pattern check
        else if value.chars().all(|c| c.is_digit(10) || c == '.') && value.matches('.').count() == 3 {
            return Some("ip_address".to_string());
        }
    }
    
    None
}

/// Extract the main value of an entity from parsed data
fn extract_entity_value(obj: &serde_json::Map<String, serde_json::Value>, entity_type: &str) -> Option<String> {
    // Check for direct value field
    if let Some(serde_json::Value::String(value)) = obj.get("value") {
        return Some(value.clone());
    }
    
    // Check for type-specific fields
    match entity_type {
        "email" => {
            if let Some(serde_json::Value::String(email)) = obj.get("email") {
                return Some(email.clone());
            }
        },
        "domain" => {
            for key in ["domain", "hostname", "host"] {
                if let Some(serde_json::Value::String(domain)) = obj.get(key) {
                    return Some(domain.clone());
                }
            }
        },
        "username" => {
            for key in ["username", "user"] {
                if let Some(serde_json::Value::String(username)) = obj.get(key) {
                    return Some(username.clone());
                }
            }
        },
        "phone" => {
            for key in ["phone", "number", "phoneNumber"] {
                if let Some(serde_json::Value::String(phone)) = obj.get(key) {
                    return Some(phone.clone());
                }
            }
        },
        "ip_address" => {
            for key in ["ip", "ipv4", "ipv6", "ip_address"] {
                if let Some(serde_json::Value::String(ip)) = obj.get(key) {
                    return Some(ip.clone());
                }
            }
        },
        _ => {
            // For other types, try common fields
            for key in ["name", "id", "identifier", "data"] {
                if let Some(serde_json::Value::String(value)) = obj.get(key) {
                    return Some(value.clone());
                }
            }
        }
    }
    
    None
}

/// Calculate confidence score for an entity
fn calculate_confidence(item: &serde_json::Value, source: &str) -> f32 {
    // Source reliability weights (adjust based on tool reliability)
    let source_reliability = match source {
        "bbot" => 0.9,
        "sherlock" => 0.8,
        "spiderfoot" => 0.85,
        "theHarvester" => 0.75,
        "phoneinfoga" => 0.8,
        "holehe" => 0.75,
        "maigret" => 0.8,
        "recon-ng" => 0.85,
        _ => 0.7, // Default for unknown sources
    };
    
    // Adjust confidence based on data quality
    let mut confidence_adjustment = 0.0;
    
    if let serde_json::Value::Object(obj) = item {
        // More attributes generally means more confidence
        confidence_adjustment += 0.05 * (obj.len().min(5) as f32);
        
        // Check if confidence or similar field is already provided
        if let Some(serde_json::Value::Number(conf)) = obj.get("confidence") {
            if let Some(conf_f) = conf.as_f64() {
                return conf_f as f32;
            }
        }
        
        // Presence of verification fields increases confidence
        for key in ["verified", "validated", "confirmed"] {
            if let Some(serde_json::Value::Bool(verified)) = obj.get(key) {
                if *verified {
                    confidence_adjustment += 0.15;
                }
            }
        }
    }
    
    // Ensure confidence is between 0.0 and 1.0
    (source_reliability + confidence_adjustment).min(1.0).max(0.0)
}

/// Convert a serde_json Value to a string if it's a simple type
fn value_to_string(value: &serde_json::Value) -> Option<String> {
    match value {
        serde_json::Value::String(s) => Some(s.clone()),
        serde_json::Value::Number(n) => Some(n.to_string()),
        serde_json::Value::Bool(b) => Some(b.to_string()),
        serde_json::Value::Null => Some("null".to_string()),
        _ => None, // Skip complex objects and arrays
    }
}