#!/bin/bash

# Enhanced Network Interface Control Script for OSINT Command Center
# Controls routing of OSINT traffic through different network interfaces
# with additional security features to prevent leaks

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Constants
OSINT_TABLE="osint"
OSINT_MARK="1"
DNS_SERVERS_SECURE="1.1.1.1 9.9.9.9"  # Privacy-focused DNS servers
ORIGINAL_RESOLV_CONF="/etc/resolv.conf.original"

# Check if running as root
if [ "$EUID" -ne 0 ]; then
  echo -e "${RED}Please run as root${NC}"
  exit 1
fi

# Function to backup original resolv.conf if not done yet
backup_resolv_conf() {
  if [ ! -f "$ORIGINAL_RESOLV_CONF" ]; then
    cp /etc/resolv.conf "$ORIGINAL_RESOLV_CONF"
    echo -e "${GREEN}Original DNS configuration backed up${NC}"
  fi
}

# Function to set secure DNS servers
set_secure_dns() {
  local interface=$1
  
  # Backup original resolv.conf
  backup_resolv_conf
  
  # Get interface-specific DNS or use secure defaults
  local dns_servers="$DNS_SERVERS_SECURE"
  
  # For VPN interfaces, try to use their DNS
  if [[ "$interface" == "tun"* || "$interface" == "wg"* ]]; then
    # Try to get VPN DNS servers from the interface
    local vpn_dns=$(ip route show dev "$interface" | grep "dhcp" | awk '{print $3}')
    if [ -n "$vpn_dns" ]; then
      dns_servers="$vpn_dns"
    else
      # Use Mullvad DNS if it's Mullvad VPN
      if vpn status 2>/dev/null | grep -q "Mullvad"; then
        dns_servers="10.64.0.1"
      fi
    fi
  fi
  
  # Create new resolv.conf
  echo -e "${YELLOW}Setting DNS servers to: $dns_servers${NC}"
  echo "# Generated by OSINT network control script" > /etc/resolv.conf
  for dns in $dns_servers; do
    echo "nameserver $dns" >> /etc/resolv.conf
  done
  
  # Add search domain if in original config
  if grep -q "search" "$ORIGINAL_RESOLV_CONF"; then
    grep "search" "$ORIGINAL_RESOLV_CONF" >> /etc/resolv.conf
  fi
  
  # Add options if in original config
  if grep -q "options" "$ORIGINAL_RESOLV_CONF"; then
    grep "options" "$ORIGINAL_RESOLV_CONF" >> /etc/resolv.conf
  else
    # Add some safe DNS options
    echo "options timeout:2 attempts:3 rotate single-request-reopen" >> /etc/resolv.conf
  fi
  
  echo -e "${GREEN}DNS configuration updated${NC}"
}

# Function to restore original DNS settings
restore_dns() {
  if [ -f "$ORIGINAL_RESOLV_CONF" ]; then
    cp "$ORIGINAL_RESOLV_CONF" /etc/resolv.conf
    echo -e "${GREEN}Original DNS configuration restored${NC}"
  else
    echo -e "${YELLOW}No original DNS configuration backup found${NC}"
  fi
}

# Function to list available network interfaces
list_interfaces() {
  echo -e "${BLUE}Available network interfaces:${NC}"
  echo -e "${YELLOW}------------------------------${NC}"
  
  # Get list of interfaces
  interfaces=$(ip -o link show | grep -v "lo:" | awk -F': ' '{print $2}')
  
  # Print interface details
  for iface in $interfaces; do
    # Get IP address
    ip_addr=$(ip -o -4 addr show dev $iface 2>/dev/null | awk '{print $4}' | cut -d/ -f1)
    if [ -z "$ip_addr" ]; then
      ip_addr="No IPv4 address"
    fi
    
    # Get interface status
    state=$(cat /sys/class/net/$iface/operstate 2>/dev/null || echo "unknown")
    
    # Get MAC address
    mac=$(cat /sys/class/net/$iface/address 2>/dev/null || echo "unknown")
    
    # Check if it's the default route
    is_default=$(ip route | grep "default" | grep $iface)
    if [ -n "$is_default" ]; then
      default_mark="${GREEN}*DEFAULT*${NC}"
    else
      default_mark=""
    fi
    
    # Check interface type
    if [[ $iface == usb* ]] || [[ $iface == enp0s*u* ]]; then
      device_type="${BLUE}[USB/Mobile]${NC}"
    elif [[ $iface == wl* ]]; then
      device_type="${BLUE}[Wireless]${NC}"
    elif [[ $iface == tun* ]] || [[ $iface == wg* ]]; then
      device_type="${BLUE}[VPN]${NC}"
    else
      device_type="${BLUE}[Wired]${NC}"
    fi
    
    # Print info
    echo -e "${GREEN}$iface${NC} $device_type $default_mark"
    echo -e "  IP address: ${YELLOW}$ip_addr${NC}"
    echo -e "  MAC: ${YELLOW}$mac${NC}"
    echo -e "  State: ${YELLOW}$state${NC}"
    
    # If USB device, try to get more info about the connected phone
    if [[ $iface == usb* ]] || [[ $iface == enp0s*u* ]]; then
      if [ -x "$(command -v lsusb)" ]; then
        # Extract bus and device ID from the interface name or sys path
        for usb_dev in $(find /sys/class/net/$iface -maxdepth 3 -name "idVendor" | xargs dirname); do
          vendor=$(cat $usb_dev/idVendor 2>/dev/null)
          product=$(cat $usb_dev/idProduct 2>/dev/null)
          if [ -n "$vendor" ] && [ -n "$product" ]; then
            device_info=$(lsusb -d $vendor:$product 2>/dev/null | cut -d' ' -f7- || echo "Unknown USB device")
            echo -e "  Device: ${YELLOW}$device_info${NC}"
          fi
        done
      fi
    fi
    
    echo ""
  done
  
  # Show current routing
  current_routing
}

# Function to display current routing information
current_routing() {
  echo -e "${BLUE}Current default route:${NC}"
  echo -e "${YELLOW}------------------------------${NC}"
  ip route | grep default
  echo ""
  
  echo -e "${BLUE}Current OSINT tool routing:${NC}"
  echo -e "${YELLOW}------------------------------${NC}"
  if [ -f /etc/iproute2/rt_tables.d/osint.conf ] || grep -q "$OSINT_TABLE" /etc/iproute2/rt_tables; then
    echo -e "${GREEN}OSINT traffic is routed through custom table${NC}"
    route_info=$(ip route show table $OSINT_TABLE 2>/dev/null)
    if [ -n "$route_info" ]; then
      echo -e "Routes: $route_info"
    else
      echo -e "${YELLOW}No routes in OSINT table${NC}"
    fi
    
    # Show rules
    echo -e "\n${BLUE}Routing rules:${NC}"
    ip rule show | grep $OSINT_TABLE
  else
    echo -e "${YELLOW}OSINT traffic follows default routing${NC}"
  fi
  
  # Show DNS configuration
  echo -e "\n${BLUE}DNS configuration:${NC}"
  echo -e "${YELLOW}------------------------------${NC}"
  cat /etc/resolv.conf | grep -v "#" | grep .
  
  # Show iptables rules if any
  if iptables -t mangle -L | grep -q "MARK"; then
    echo -e "\n${BLUE}OSINT iptables rules:${NC}"
    echo -e "${YELLOW}------------------------------${NC}"
    iptables -t mangle -L PREROUTING -v 2>/dev/null | grep "MARK" || true
    iptables -t mangle -L OUTPUT -v 2>/dev/null | grep "MARK" || true
  fi
  
  # Check IPv6 status (optional - for leak prevention)
  echo -e "\n${BLUE}IPv6 status:${NC}"
  if sysctl -a 2>/dev/null | grep -q "net.ipv6.conf.all.disable_ipv6 = 1"; then
    echo -e "${GREEN}IPv6 is disabled (preventing IPv6 leaks)${NC}"
  else
    echo -e "${YELLOW}IPv6 is enabled (potential leak vector)${NC}"
    echo -e "${YELLOW}Tip: Run 'sysctl -w net.ipv6.conf.all.disable_ipv6=1' to disable${NC}"
  fi
}

# Function to check if an interface exists
check_interface() {
  if [ ! -d "/sys/class/net/$1" ]; then
    echo -e "${RED}Error: Interface $1 does not exist${NC}"
    return 1
  fi
  return 0
}

# Function to check if interface has IPv4 address
check_interface_ip() {
  ip_addr=$(ip -o -4 addr show dev $1 2>/dev/null | awk '{print $4}' | cut -d/ -f1)
  if [ -z "$ip_addr" ]; then
    echo -e "${RED}Error: Interface $1 has no IPv4 address${NC}"
    return 1
  fi
  return 0
}

# Function to set up leak-proof routing for a specific interface
setup_routing() {
  local iface=$1
  local user=$2
  
  # Check if interface exists
  check_interface $iface || return 1
  
  # Check if interface has IP
  check_interface_ip $iface || return 1
  
  # Get interface details
  ip_addr=$(ip -o -4 addr show dev $iface | awk '{print $4}' | cut -d/ -f1)
  gateway=$(ip route | grep $iface | grep default | awk '{print $3}')
  
  # If no gateway is found, try to determine it
  if [ -z "$gateway" ]; then
    # Try to find the network address
    network=$(ip route | grep $iface | grep -v default | head -1 | awk '{print $1}')
    if [ -n "$network" ]; then
      # Use the first hop in the network as gateway
      gateway=$(echo $network | cut -d/ -f1 | sed 's/[0-9]*$/1/')
      echo -e "${YELLOW}Warning: No default gateway found for $iface. Using $gateway as assumed gateway${NC}"
    else
      echo -e "${RED}Error: Cannot determine gateway for $iface${NC}"
      return 1
    fi
  fi
  
  echo -e "${BLUE}Setting up OSINT routing through $iface ($ip_addr)...${NC}"
  
  # Create osint routing table if it doesn't exist
  if ! grep -q "$OSINT_TABLE" /etc/iproute2/rt_tables && ! grep -q "$OSINT_TABLE" /etc/iproute2/rt_tables.d/osint.conf 2>/dev/null; then
    mkdir -p /etc/iproute2/rt_tables.d
    echo "200 $OSINT_TABLE" > /etc/iproute2/rt_tables.d/osint.conf
    echo -e "${GREEN}Created OSINT routing table${NC}"
  fi
  
  # Flush existing rules and routes
  ip rule del fwmark $OSINT_MARK lookup $OSINT_TABLE 2>/dev/null
  ip route flush table $OSINT_TABLE 2>/dev/null
  
  # Remove existing iptables rules for the user
  iptables -t mangle -D OUTPUT -m owner --uid-owner $user -j MARK --set-mark $OSINT_MARK 2>/dev/null
  
  # Create new routing table and routes
  echo -e "${YELLOW}Setting up routing table...${NC}"
  
  # First add a local route for the interface
  ip route add table $OSINT_TABLE $(ip route | grep $iface | grep -v default | head -1)
  
  # Then add the default route
  ip route add default via $gateway dev $iface table $OSINT_TABLE
  
  # Add routing rule
  ip rule add fwmark $OSINT_MARK lookup $OSINT_TABLE
  
  # Set up iptables to mark packets from the specified user
  echo -e "${YELLOW}Setting up packet marking for user $user...${NC}"
  iptables -t mangle -A OUTPUT -m owner --uid-owner $user -j MARK --set-mark $OSINT_MARK
  
  # Set up secure DNS to prevent DNS leaks
  echo -e "${YELLOW}Setting up secure DNS configuration...${NC}"
  set_secure_dns $iface
  
  # Consider disabling IPv6 to prevent leaks
  echo -e "${YELLOW}Disabling IPv6 to prevent leaks...${NC}"
  sysctl -w net.ipv6.conf.all.disable_ipv6=1 > /dev/null
  sysctl -w net.ipv6.conf.default.disable_ipv6=1 > /dev/null
  
  echo -e "${GREEN}Routing successfully configured!${NC}"
  echo -e "${GREEN}All traffic from user '$user' will now go through $iface${NC}"
  
  # Display the current routing
  current_routing
  
  # Add killswitch to prevent leaks if interface goes down (optional)
  echo -e "${YELLOW}Setting up network killswitch for leak prevention...${NC}"
  
  # Create killswitch script in /etc/network/if-down.d/
  mkdir -p /etc/network/if-down.d/
  cat > "/etc/network/if-down.d/osint-killswitch-$iface" << EOF
#!/bin/bash
if [ "\$IFACE" = "$iface" ]; then
  logger -t osint-network "Killswitch activated for $iface going down"
  iptables -F OUTPUT
  iptables -A OUTPUT -m owner --uid-owner $user -j DROP
  iptables -A OUTPUT -o lo -j ACCEPT
fi
EOF
  chmod +x "/etc/network/if-down.d/osint-killswitch-$iface"
  
  echo -e "${GREEN}Killswitch configured. If $iface goes down, all traffic from $user will be blocked.${NC}"
}

# Function to reset routing to default
reset_routing() {
  echo -e "${BLUE}Resetting OSINT routing to default...${NC}"
  
  # Flush rules and routes
  ip rule del fwmark $OSINT_MARK lookup $OSINT_TABLE 2>/dev/null
  ip route flush table $OSINT_TABLE 2>/dev/null
  
  # Remove iptables rules
  iptables -t mangle -F OUTPUT 2>/dev/null
  
  # Remove killswitch scripts
  rm -f /etc/network/if-down.d/osint-killswitch-*
  
  # Restore original DNS settings
  restore_dns
  
  # Re-enable IPv6 if it was disabled
  sysctl -w net.ipv6.conf.all.disable_ipv6=0 > /dev/null
  sysctl -w net.ipv6.conf.default.disable_ipv6=0 > /dev/null
  
  echo -e "${GREEN}Routing reset to default${NC}"
  
  # Display the current routing
  current_routing
}

# Function to setup USB tethering with Android phone
setup_usb_tethering() {
  echo -e "${BLUE}Setting up USB tethering with mobile phone...${NC}"
  
  # Check if any suitable device is connected
  if ! lsusb | grep -qE "Android|Google|Samsung|Xiaomi|Huawei|OnePlus|LG|Sony|HTC|Apple|iPhone"; then
    echo -e "${RED}No mobile phone detected via USB.${NC}"
    echo -e "${YELLOW}Please connect your phone via USB and enable USB tethering in your phone's settings.${NC}"
    return 1
  fi
  
  echo -e "${YELLOW}Looking for USB network interfaces...${NC}"
  
  # Find USB network interfaces
  usb_ifaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E "usb|enp0s.*u")
  
  if [ -z "$usb_ifaces" ]; then
    echo -e "${RED}No USB network interfaces found.${NC}"
    echo -e "${YELLOW}Make sure USB tethering is enabled on your phone.${NC}"
    
    # Try to detect Android device and trigger tethering setup
    if lsusb | grep -q "Android"; then
      echo -e "${YELLOW}Android device detected. Attempting to trigger USB tethering...${NC}"
      
      # For some Android phones, writing to USB configuration can trigger tethering
      for android_dev in /sys/class/android_usb/android*/functions; do
        if [ -f "$android_dev" ]; then
          echo "rndis,acm,mass_storage" > "$android_dev" 2>/dev/null || true
        fi
      done
      
      # Wait a bit and check again
      sleep 3
      usb_ifaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E "usb|enp0s.*u")
      
      if [ -z "$usb_ifaces" ]; then
        echo -e "${RED}Still no USB network interfaces found.${NC}"
        return 1
      fi
    elif lsusb | grep -q "Apple"; then
      echo -e "${YELLOW}iOS device detected. Make sure Personal Hotspot is enabled.${NC}"
      
      # For iOS devices, try to initialize the interface
      if command -v idevicepair &> /dev/null; then
        echo -e "${YELLOW}Attempting to pair with iOS device...${NC}"
        idevicepair pair
      fi
    else
      return 1
    fi
  fi
  
  echo -e "${GREEN}Found USB network interfaces: $usb_ifaces${NC}"
  
  # Check for multiple interfaces
  usb_iface_count=$(echo $usb_ifaces | wc -w)
  if [ $usb_iface_count -gt 1 ]; then
    echo -e "${YELLOW}Multiple USB interfaces found. Please select one:${NC}"
    select iface in $usb_ifaces; do
      if [ -n "$iface" ]; then
        usb_iface=$iface
        break
      fi
    done
  else
    usb_iface=$usb_ifaces
  fi
  
  echo -e "${GREEN}Selected interface: $usb_iface${NC}"
  
  # Make sure the interface is up
  ip link set $usb_iface up
  
  # Try to get IP via DHCP if not already assigned
  if ! ip -o -4 addr show dev $usb_iface | grep -q "inet"; then
    echo -e "${YELLOW}Requesting IP address via DHCP...${NC}"
    # Try multiple DHCP clients in order of preference
    if command -v dhclient &> /dev/null; then
      dhclient -v $usb_iface
    elif command -v dhcpcd &> /dev/null; then
      dhcpcd $usb_iface
    else
      # Use networkctl for systemd-networkd
      networkctl renew $usb_iface
    fi
    
    # Wait a bit for IP assignment
    sleep 3
  fi
  
  # Check if IP was assigned
  if ! ip -o -4 addr show dev $usb_iface | grep -q "inet"; then
    echo -e "${RED}Failed to get IP address for $usb_iface${NC}"
    echo -e "${YELLOW}Please check your phone's USB tethering settings.${NC}"
    return 1
  fi
  
  # Display interface details
  ip_addr=$(ip -o -4 addr show dev $usb_iface | awk '{print $4}' | cut -d/ -f1)
  echo -e "${GREEN}Successfully connected to phone via USB tethering${NC}"
  echo -e "${GREEN}Interface: $usb_iface, IP: $ip_addr${NC}"
  
  # Set up routing (optional, prompt user)
  echo -e "${YELLOW}Do you want to route OSINT traffic through this interface? (y/n)${NC}"
  read -r choice
  if [[ $choice =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Enter username to route traffic for:${NC}"
    read -r username
    setup_routing $usb_iface $username
  fi
  
  return 0
}

# Function to perform a leak test
test_for_leaks() {
  echo -e "${BLUE}Testing for network leaks...${NC}"
  
  # Check for IPv4 leaks
  echo -e "${YELLOW}Testing IPv4 connectivity...${NC}"
  if ping -c 1 -W 2 8.8.8.8 > /dev/null 2>&1; then
    echo -e "${GREEN}IPv4 connectivity works${NC}"
  else
    echo -e "${RED}IPv4 connectivity failed - possible route issue${NC}"
  fi
  
  # Check for IPv6 leaks
  echo -e "${YELLOW}Testing IPv6 connectivity...${NC}"
  if ping -6 -c 1 -W 2 2001:4860:4860::8888 > /dev/null 2>&1; then
    echo -e "${RED}WARNING: IPv6 is accessible - potential leak vector!${NC}"
    echo -e "${YELLOW}Recommendation: Disable IPv6 with 'sysctl -w net.ipv6.conf.all.disable_ipv6=1'${NC}"
  else
    echo -e "${GREEN}IPv6 connectivity blocked - good${NC}"
  fi
  
  # Check for DNS leaks
  echo -e "${YELLOW}Testing DNS resolver...${NC}"
  dns_server=$(dig +short whoami.akamai.net 2>/dev/null | head -1)
  if [ -n "$dns_server" ]; then
    echo -e "DNS requests go through: ${YELLOW}$dns_server${NC}"
    
    # Check if this is a known privacy DNS
    if echo "$dns_server" | grep -qE "^(1\.1\.1\.|9\.9\.9\.|149\.112\.112\.|208\.67\.222\.|208\.67\.220\.|10\.64\.0\.)"; then
      echo -e "${GREEN}Using a privacy-respecting DNS server${NC}"
    else
      echo -e "${RED}WARNING: Using potentially unsafe DNS server${NC}"
      echo -e "${YELLOW}Recommendation: Configure secure DNS servers${NC}"
    fi
  else
    echo -e "${YELLOW}Could not determine DNS server${NC}"
  fi
  
  # Check public IP
  echo -e "${YELLOW}Checking current public IP...${NC}"
  public_ip=$(curl -s https://ifconfig.me)
  echo -e "Current public IP: ${YELLOW}$public_ip${NC}"
  
  # Check if VPN is active
  if command -v vpn &> /dev/null; then
    echo -e "${YELLOW}Checking VPN status...${NC}"
    if vpn status | grep -q "VPN is active"; then
      echo -e "${GREEN}VPN is active${NC}"
      
      # Try to check if IP matches VPN provider
      if curl -s https://am.i.mullvad.net/json 2>/dev/null | grep -q "mullvad_exit_ip"; then
        echo -e "${GREEN}Successfully using Mullvad VPN exit node${NC}"
      fi
    else
      echo -e "${RED}VPN is not active${NC}"
      echo -e "${YELLOW}Recommendation: Enable VPN with 'vpn on'${NC}"
    fi
  fi
  
  # Check if Tor is active
  if command -v tor-control &> /dev/null; then
    echo -e "${YELLOW}Checking Tor status...${NC}"
    if systemctl is-active tor >/dev/null 2>&1 && tor-control status | grep -q "connected through Tor"; then
      echo -e "${GREEN}Tor routing is active${NC}"
    else
      echo -e "${YELLOW}Tor routing is not active${NC}"
    fi
  fi
  
  echo -e "${GREEN}Leak test completed${NC}"
}

# Function to show help
show_help() {
  echo -e "${GREEN}Enhanced Network Interface Control for OSINT Tools${NC}"
  echo -e "${YELLOW}-----------------------------------------------${NC}"
  echo -e "This script allows you to control which network interface your OSINT tools use,"
  echo -e "with advanced security features to prevent data leaks."
  echo -e ""
  echo -e "${BLUE}Usage:${NC}"
  echo -e "  ${YELLOW}list${NC}             - List all available network interfaces"
  echo -e "  ${YELLOW}status${NC}           - Show current routing status"
  echo -e "  ${YELLOW}use${NC} IFACE USER   - Route OSINT traffic from USER through IFACE"
  echo -e "  ${YELLOW}reset${NC}            - Reset routing to system default"
  echo -e "  ${YELLOW}phone${NC}            - Set up USB tethering with phone"
  echo -e "  ${YELLOW}leaktest${NC}         - Test for potential network leaks"
  echo -e "  ${YELLOW}help${NC}             - Show this help"
  echo -e ""
  echo -e "${BLUE}Examples:${NC}"
  echo -e "  ${YELLOW}$0 list${NC}"
  echo -e "  ${YELLOW}$0 use wlan0 campo${NC}      - Route 'campo' user traffic through WiFi"
  echo -e "  ${YELLOW}$0 use usb0 campo${NC}       - Route 'campo' user traffic through USB tethered phone"
  echo -e "  ${YELLOW}$0 use wg0 campo${NC}        - Route 'campo' user traffic through WireGuard VPN"
  echo -e "  ${YELLOW}$0 phone${NC}                - Set up USB tethering with phone"
  echo -e "  ${YELLOW}$0 leaktest${NC}             - Run network leak test"
  echo -e ""
  echo -e "${YELLOW}Security Features:${NC}"
  echo -e "  - Secure DNS configuration to prevent DNS leaks"
  echo -e "  - IPv6 disabling to prevent IPv6 leaks"
  echo -e "  - Network killswitch to prevent leaks if interface goes down"
  echo -e "  - Comprehensive leak testing"
  echo -e ""
}

# Main script logic
case "$1" in
  list)
    list_interfaces
    ;;
    
  status)
    current_routing
    ;;
    
  use)
    if [ -z "$2" ] || [ -z "$3" ]; then
      echo -e "${RED}Error: Missing arguments${NC}"
      echo -e "${YELLOW}Usage: $0 use INTERFACE USERNAME${NC}"
      exit 1
    fi
    setup_routing $2 $3
    ;;
    
  reset)
    reset_routing
    ;;
    
  phone)
    setup_usb_tethering
    ;;
    
  leaktest)
    test_for_leaks
    ;;
    
  help|--help|-h)
    show_help
    ;;
    
  *)
    show_help
    exit 1
    ;;
esac

exit 0